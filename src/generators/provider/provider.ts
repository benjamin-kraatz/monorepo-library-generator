/**
 * Provider Generator
 *
 * Generates a provider library following Effect-based architecture patterns
 * with standardized structure, configuration, and build setup.
 *
 * Uses centralized library generation utilities for consistency.
 */

import type { Tree } from "@nx/devkit"
import { formatFiles, installPackagesTask, names } from "@nx/devkit"
import { generateLibraryFiles, type LibraryGeneratorOptions } from "../../utils/library-generator-utils"
import { normalizeBaseOptions } from "../../utils/normalization-utils"
import type { ProviderTemplateOptions } from "../../utils/shared/types"
import type { NormalizedProviderOptions, ProviderGeneratorSchema } from "./schema"
import { generateErrorsFile } from "./templates/errors.template"
import { generateLayersFile } from "./templates/layers.template"
import { generateServiceSpecFile } from "./templates/service-spec.template"
import { generateServiceFile } from "./templates/service.template"
import { generateTypesFile } from "./templates/types.template"
import { generateValidationFile } from "./templates/validation.template"

/**
 * Normalize and validate generator options
 */
function normalizeOptions(
  tree: Tree,
  options: ProviderGeneratorSchema
): NormalizedProviderOptions {
  // Validate required fields
  if (!options.name || options.name.trim() === "") {
    throw new Error("Provider name is required")
  }
  if (!options.externalService || options.externalService.trim() === "") {
    throw new Error("External service name is required")
  }

  // Platform determination
  const platform = options.platform || "node"
  const includeClientServer = platform === "universal" ? true : (options.includeClientServer ?? false)

  // Use shared normalization (without additional tags, we'll build tags manually)
  const baseOptions = normalizeBaseOptions(tree, {
    name: options.name,
    ...(options.directory !== undefined && { directory: options.directory }),
    description: options.description ?? `${names(options.name).className} provider for ${options.externalService}`,
    libraryType: "provider"
  })

  // Provider-specific naming: use "Service" suffix instead of "Provider"
  const projectClassName = `${baseOptions.className}Service`
  const projectConstantName = `${baseOptions.constantName}_SERVICE`

  // Provider-specific tags: always use "scope:provider" instead of "scope:${fileName}"
  const serviceTag = `service:${names(options.externalService).fileName}`
  const defaultTags = [
    "type:provider",
    "scope:provider", // Providers always use "provider" scope
    `platform:${platform}`,
    serviceTag
  ]
  const parsedTags = options.tags ? [...defaultTags, ...options.tags.split(",").map((t) => t.trim())] : defaultTags

  return {
    ...baseOptions,
    externalService: options.externalService,
    platform,
    includeClientServer,
    projectClassName,
    projectConstantName,
    parsedTags
  }
}

/**
 * Generate domain-specific template files using code-based templates
 * Only generates files specific to provider pattern (service.ts, errors.ts, layers.ts, etc.)
 * All infrastructure files are now generated by library-generator-utils
 */
function addDomainFiles(tree: Tree, options: NormalizedProviderOptions) {
  const nameVariations = names(options.name)

  // Map PlatformType to Platform for template options
  const platformMapping = {
    node: "server" as const,
    browser: "client" as const,
    edge: "edge" as const,
    universal: "universal" as const
  }

  const templateOptions: ProviderTemplateOptions = {
    // Naming variants
    name: options.name,
    className: nameVariations.className,
    propertyName: nameVariations.propertyName,
    fileName: nameVariations.fileName,
    constantName: nameVariations.constantName,

    // Library metadata
    libraryType: "provider",
    packageName: `@custom-repo/${options.projectName}`,
    projectName: options.projectName,
    projectRoot: options.projectRoot,
    sourceRoot: `${options.projectRoot}/src`,
    offsetFromRoot: options.offsetFromRoot,
    description: options.description,
    tags: options.parsedTags,

    // Provider-specific
    externalService: options.externalService,
    platforms: [platformMapping[options.platform]]
  }

  const sourceLibPath = `${templateOptions.sourceRoot}/lib`

  // Generate all provider-specific files using code-based templates
  tree.write(`${sourceLibPath}/errors.ts`, generateErrorsFile(templateOptions))
  tree.write(`${sourceLibPath}/types.ts`, generateTypesFile(templateOptions))
  tree.write(
    `${sourceLibPath}/validation.ts`,
    generateValidationFile(templateOptions)
  )
  tree.write(
    `${sourceLibPath}/service.ts`,
    generateServiceFile(templateOptions)
  )
  tree.write(`${sourceLibPath}/layers.ts`, generateLayersFile(templateOptions))
  tree.write(
    `${sourceLibPath}/service.spec.ts`,
    generateServiceSpecFile(templateOptions)
  )
}

/**
 * Main provider generator function
 *
 * Simplified to use centralized library generation utilities.
 * This ensures consistency across all library types.
 */
export default async function providerGenerator(
  tree: Tree,
  options: ProviderGeneratorSchema
) {
  const normalizedOptions = normalizeOptions(tree, options)

  // Generate ALL library files using centralized utility
  const libraryOptions: LibraryGeneratorOptions = {
    name: normalizedOptions.name,
    projectName: normalizedOptions.projectName,
    projectRoot: normalizedOptions.projectRoot,
    offsetFromRoot: normalizedOptions.offsetFromRoot,
    libraryType: "provider",
    platform: normalizedOptions.platform,
    description: normalizedOptions.description,
    tags: normalizedOptions.parsedTags,
    includeClientServer: normalizedOptions.includeClientServer,
    includeEdgeExports: normalizedOptions.platform === "edge",
    templateData: {
      externalService: normalizedOptions.externalService,
      projectClassName: normalizedOptions.projectClassName,
      projectConstantName: normalizedOptions.projectConstantName
    }
  }

  await generateLibraryFiles(tree, libraryOptions)

  // Generate domain-specific files (service.ts, errors.ts, layers.ts)
  addDomainFiles(tree, normalizedOptions)

  // Format files and install packages
  await formatFiles(tree)
  return () => {
    installPackagesTask(tree)
  }
}
